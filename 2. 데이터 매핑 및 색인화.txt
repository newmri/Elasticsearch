

동시성 처리: 문서를 업데이트 하거나 할때 seq_no랑 primary_term도 인자로 전달
이미 다른 사람이 업데이트 했으면 에러 발생 다시 조회후 새로운 seq_no랑 primary_term 으로 다시 시도
데이터 모델링: 페어런트-차일드 관계 설정 가능

인덱스에 새로운 필드는 자주 추가하면 클러스터 상태가 커지고 모든 노드에 걸쳐 상태 업데이트를 유발하여 느려질 수 있음
심지어 클러스터 크래시 까지 가능 (매핑 폭발), 이를 방지하기 위해 Flattened 데이터 유형 추가됨 (전체 객체와 그 내부 필드를 단일 필드로 매핑)
부모 필드를 Flattened 라는 단일 유형으로 매핑하고 내부 필드는 매핑에 나타나지 않음 따라서 전체 맵 필드를 줄임
Flattend Data Type Object의 Field가 Elasticsearch에서 keyword로 처리된다
 - 이는 Analyzer, Tokenizer가 적용되지 않는다는 말이다.
 - 따라서 검색 기능이 제한된다.

매핑
 - Process: JSON 문서가 인덱스에 저장되는 방식을 정의
 	- 명시적 매핑: 필드와 타입을 사전에 정의
 	- 동적 매핑: 자동으로 매핑
 - Result: 실제 메타 데이터 결과
 	- 개별 필드와 데이터 유형을 통해 무엇을 인덱싱 할 수 있는지 그리고 변수를 통해 인덱싱이 어떻게 이루어지는지 정의

index.mapping.total.fields.limit: 한 인덱스의 필드 제한 갯수

| 개념        | 엘라스틱서치            | MySQL    |
| --------- | ----------------- | -------- |
| 데이터베이스    | 클러스터 (전체)         | Database |
| 테이블       | **인덱스 (index)**   | Table    |
| 행(row)    | **문서 (document)** | Row      |
| 열(column) | **필드 (field)**    | Column   |

참고로 하나의 인덱스에 서로 다른 타입을 가진 여러 문서 존재 가능

EX)
{ "type": "user", "name": "Alice", "age": 25 }
{ "type": "order", "order_id": 101, "amount": 500 }

타입이 다르면 인덱스도 다르게 쓰는게 맞지 않나 싶은데

| 방법            | 장점                | 단점                                                    |
| ------------- | ----------------- | ----------------------------------------------------- |
| 문서 구조별 인덱스 분리 | 매핑 충돌 없음, 관리 쉬움   | 검색/집계 시 인덱스 여러 개 조회 필요                                |
| 하나의 인덱스에 혼합   | 한 번에 검색 가능, 분석 편리 | 매핑 복잡, 필드 수 제한(`index.mapping.total.fields.limit`) 주의 |


